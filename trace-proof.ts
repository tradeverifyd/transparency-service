// Manual trace of oldSize=3, newSize=4 consistency proof

function hexToBytes(hex: string): Uint8Array {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) {
    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  }
  return bytes;
}

async function hashNode(left: Uint8Array, right: Uint8Array): Promise<Uint8Array> {
  const data = new Uint8Array(1 + left.length + right.length);
  data[0] = 0x01;
  data.set(left, 1);
  data.set(right, 1 + left.length);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return new Uint8Array(hashBuffer);
}

async function hashLeaf(leaf: Uint8Array): Promise<Uint8Array> {
  const data = new Uint8Array(1 + leaf.length);
  data[0] = 0x00;
  data.set(leaf, 1);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  return new Uint8Array(hashBuffer);
}

function bytesToHex(b: Uint8Array): string {
  return Array.from(b).map(x => x.toString(16).padStart(2, '0')).join('');
}

async function main() {
  // From test vectors
  const oldRoot = hexToBytes("ba8d94b7fbcecae7b81c4c80574fe24734a6917bf9c1ecd66ff3e0c34ead4620");
  const newRoot = hexToBytes("fdea52008cdae79fa8bf806261959e23f5e11681646a2fa2bc9b5e56b32030a2");
  const proof = [hexToBytes("acaa04663a8547a2f70c60cc18f9378796b13c4f9a08f70d6adae662365b30c6")];

  console.log("=== Test Case: oldSize=3, newSize=4 ===");
  console.log("oldRoot:", bytesToHex(oldRoot));
  console.log("newRoot:", bytesToHex(newRoot));
  console.log("proof[0]:", bytesToHex(proof[0]));

  // Manually reconstruct trees to understand structure
  // Leaves (raw data)
  const leaf0 = new Uint8Array(32).fill(0);
  const leaf1 = new Uint8Array(32).fill(1);
  const leaf2 = new Uint8Array(32).fill(2);
  const leaf3 = new Uint8Array(32).fill(3);

  // Compute leaf hashes
  const h0 = await hashLeaf(leaf0);
  const h1 = await hashLeaf(leaf1);
  const h2 = await hashLeaf(leaf2);
  const h3 = await hashLeaf(leaf3);

  console.log("\n=== Leaf Hashes ===");
  console.log("h0:", bytesToHex(h0));
  console.log("h1:", bytesToHex(h1));
  console.log("h2:", bytesToHex(h2));
  console.log("h3:", bytesToHex(h3));

  // Tree size 3 structure: hash(hash(h0,h1), h2)
  const h01 = await hashNode(h0, h1);
  const root3 = await hashNode(h01, h2);
  
  console.log("\n=== Tree Size 3 ===");
  console.log("hash(h0,h1):", bytesToHex(h01));
  console.log("root3:", bytesToHex(root3));
  console.log("Expected oldRoot:", bytesToHex(oldRoot));
  console.log("Match:", bytesToHex(root3) === bytesToHex(oldRoot));

  // Tree size 4 structure: hash(hash(h0,h1), hash(h2,h3))
  const h23 = await hashNode(h2, h3);
  const root4 = await hashNode(h01, h23);

  console.log("\n=== Tree Size 4 ===");
  console.log("hash(h2,h3):", bytesToHex(h23));
  console.log("root4:", bytesToHex(root4));
  console.log("Expected newRoot:", bytesToHex(newRoot));
  console.log("Match:", bytesToHex(root4) === bytesToHex(newRoot));

  // Check what the proof hash represents
  console.log("\n=== Proof Analysis ===");
  console.log("proof[0]:", bytesToHex(proof[0]));
  console.log("Is it h3?:", bytesToHex(proof[0]) === bytesToHex(h3));
  console.log("Is it h2?:", bytesToHex(proof[0]) === bytesToHex(h2));
  console.log("Is it h23?:", bytesToHex(proof[0]) === bytesToHex(h23));

  // Now trace what runTreeProof should do
  console.log("\n=== Manual runTreeProof Trace ===");
  console.log("runTreeProof(p=[proof[0]], lo=0, hi=4, n=3, oldRoot)");
  console.log("  lo < n (0 < 3) ✓");
  console.log("  n <= hi (3 <= 4) ✓");
  console.log("  n != hi (3 != 4), so not base case");
  console.log("  k = largestPowerOfTwoLessThan(4-0) = 2");
  console.log("  n <= lo+k? (3 <= 0+2) = false");
  console.log("  So we go RIGHT: runTreeProof(p=[], lo=2, hi=4, n=3, oldRoot)");
  console.log("\nrunTreeProof(p=[], lo=2, hi=4, n=3, oldRoot)");
  console.log("  lo < n (2 < 3) ✓");
  console.log("  n <= hi (3 <= 4) ✓");
  console.log("  n != hi (3 != 4), so not base case");
  console.log("  p.length === 0 → ERROR: Proof too short!");
  
  console.log("\n=== The Problem ===");
  console.log("The algorithm tries to recurse but runs out of proof elements.");
  console.log("This suggests the proof structure generated by Go might be different,");
  console.log("OR our runTreeProof implementation has a bug.");
}

await main();
