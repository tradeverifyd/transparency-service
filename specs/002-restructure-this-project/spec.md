# Feature Specification: Dual-Language Project Restructure

**Feature Branch**: `002-restructure-this-project`
**Created**: 2025-10-12
**Status**: Draft
**Input**: User description: "restructure this project so there are 2 top level directories, one for typescript and bun called scitt-typescript and one for golang called scitt-golang, ensure that all the library, cli and server features are present in both typscript and go and that there are cross tests for each key user story. Make sure that each project supports simple cli commands for creating keys, creating issuer identities that can be hosted in .well-known uris, maek sure that statements, and signed statements and receipts are implemented and interopable. Make sure the readme makes it easy for users to choose go or typescript without needing to know the other. Make sure the library, server and cli organization structure is similar in both projects."

## Clarifications

### Session 2025-10-12

- Q: When you restructure the project into `scitt-typescript/` and `scitt-golang/` directories, where should cross-implementation interoperability tests be located? → A: Separate top-level `tests/interop/` directory that orchestrates both implementations
- Q: How should version numbers be managed across the two implementations? → A: Strict lockstep - identical versions (1.0.0 = 1.0.0) always
- Q: How should existing TypeScript code be migrated into the new `scitt-typescript/` structure? → A: Direct move - all files relocated, users update imports immediately
- Q: Where should the primary README be located after restructure? → A: Root README with language navigation, detailed READMEs in each implementation directory
- Q: Should the restructured project use a monorepo or separate repositories? → A: Monorepo - single repository with scitt-typescript/, scitt-golang/, tests/interop/ at root

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Language-Independent Quick Start (Priority: P1)

A developer wants to get started with the transparency service in their preferred language without needing to understand or install the other language's tooling.

**Why this priority**: This is the primary entry point for all users. If users can't easily choose and start with their preferred language, the project restructure fails its core purpose.

**Independent Test**: Can be fully tested by following the README instructions for either language choice independently, successfully initializing a service, and creating a first statement - without any reference to or dependency on the other language.

**Acceptance Scenarios**:

1. **Given** a developer familiar with TypeScript, **When** they read the README and choose the TypeScript path, **Then** they can install dependencies, initialize the service, and create their first statement without encountering Go-specific instructions or requirements
2. **Given** a developer familiar with Go, **When** they read the README and choose the Go path, **Then** they can build the project, initialize the service, and create their first statement without encountering TypeScript-specific instructions or requirements
3. **Given** a developer using the CLI, **When** they run help commands, **Then** the command structure and output format are consistent between both language implementations

---

### User Story 2 - Cross-Implementation Interoperability (Priority: P1)

A developer wants to create cryptographic artifacts (keys, statements, receipts) in one language implementation and verify them in the other implementation.

**Why this priority**: Interoperability is constitutionally mandated (Principle VIII) and essential for ecosystem trust. This validates that both implementations conform to the same standards.

**Independent Test**: Can be fully tested by generating a key, issuer identity, signed statement, and receipt in one implementation, then loading and verifying each artifact in the other implementation - all operations must succeed with identical results.

**Acceptance Scenarios**:

1. **Given** a key generated using one implementation, **When** that key is used to sign a statement in the other implementation, **Then** the signature verifies successfully
2. **Given** an issuer identity created in one implementation and hosted at a .well-known URI, **When** the other implementation fetches and validates it, **Then** verification succeeds
3. **Given** a signed statement created in one implementation, **When** the other implementation generates a receipt for it, **Then** the receipt validates against the original statement
4. **Given** receipts generated by both implementations for the same statement, **When** either implementation verifies either receipt, **Then** both receipts validate successfully

---

### User Story 3 - Consistent CLI Operations (Priority: P2)

A developer wants to perform the same operations via CLI commands regardless of which language implementation they choose.

**Why this priority**: Operational consistency reduces cognitive load and enables users to switch implementations or share knowledge across teams without relearning commands.

**Independent Test**: Can be fully tested by executing equivalent CLI command sequences in both implementations and comparing outputs - command names, flags, arguments, output formats, and error messages should match.

**Acceptance Scenarios**:

1. **Given** the CLI for either implementation, **When** a developer runs the key generation command, **Then** the command syntax, required flags, and output format are identical between implementations
2. **Given** the CLI for either implementation, **When** a developer creates an issuer identity, **Then** the resulting files have the same structure and can be hosted identically
3. **Given** the CLI for either implementation, **When** a developer creates a signed statement, **Then** the command flow and output artifacts are structurally equivalent
4. **Given** error conditions in either implementation, **When** CLI commands fail, **Then** error messages provide the same level of detail and actionability

---

### User Story 4 - Server Deployment Parity (Priority: P2)

A developer or operator wants to deploy a transparency service using either implementation with equivalent capabilities and configuration.

**Why this priority**: Production deployments need feature parity. Organizations may choose languages based on infrastructure, team expertise, or performance requirements.

**Independent Test**: Can be fully tested by deploying both implementations with identical configuration, exercising all API endpoints, and verifying response formats, error handling, and performance characteristics are equivalent.

**Acceptance Scenarios**:

1. **Given** a server deployed in either implementation, **When** requests are made to all API endpoints, **Then** response schemas, status codes, and error formats are identical
2. **Given** both servers running with the same configuration, **When** clients register statements, **Then** receipts from both servers validate against each other
3. **Given** both servers under load, **When** performance is measured, **Then** both implementations meet the same latency and throughput targets defined in the constitution
4. **Given** well-known endpoints (.well-known/scitt-configuration, .well-known/jwks.json), **When** clients fetch service metadata, **Then** responses are structurally identical

---

### User Story 5 - Library Integration (Priority: P3)

A developer wants to embed transparency service functionality directly into their application using the library component.

**Why this priority**: Library usage is a secondary pattern after CLI/server. However, it enables advanced integration scenarios and programmatic control.

**Independent Test**: Can be fully tested by writing minimal integration code in each language that imports the library, creates a statement, generates a receipt, and verifies it - all without CLI or server dependencies.

**Acceptance Scenarios**:

1. **Given** a library imported in either language, **When** a developer uses library functions to create keys, **Then** the API surface (function names, parameters, return types) follows parallel structures
2. **Given** statements created via library calls in one implementation, **When** those statements are loaded and verified via library calls in the other implementation, **Then** verification succeeds
3. **Given** error conditions when using the library, **When** operations fail, **Then** error types and messages are consistent across implementations

---

### Edge Cases

- What happens when a user has both implementations installed and accidentally mixes artifacts from different implementations in the same directory?
- How are releases coordinated to ensure both implementations reach the same version simultaneously (given strict lockstep versioning)?
- What happens when directory structures are navigated from the repository root vs from within a language-specific directory?
- How are breaking changes communicated when one implementation advances ahead of the other?
- What happens when interoperability tests detect divergence between implementations?
- How does documentation handle features that exist in one implementation but not yet in the other?

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: Project MUST maintain two independent top-level directories with clear naming (scitt-typescript, scitt-golang) within a single monorepo
- **FR-002**: Each implementation MUST provide library, CLI, and server components with equivalent functionality
- **FR-003**: CLI in both implementations MUST support key generation with consistent command structure
- **FR-004**: CLI in both implementations MUST support issuer identity creation compatible with .well-known URI hosting
- **FR-005**: CLI in both implementations MUST support statement creation and signing
- **FR-006**: CLI in both implementations MUST support receipt generation and verification
- **FR-007**: Server in both implementations MUST expose equivalent API endpoints following SCRAPI specification (structurally equivalent: same schema and semantics, deterministic CBOR encoding where applicable, but signatures may differ between implementations)
- **FR-008**: Libraries in both implementations MUST expose equivalent programmatic interfaces for core operations
- **FR-009**: Cross-implementation test suite MUST validate interoperability for every key user story (located in top-level `tests/interop/` directory)
- **FR-010**: Cross-implementation tests MUST verify that artifacts (keys, statements, receipts) created in one implementation work in the other
- **FR-011**: Documentation MUST provide clear, parallel paths for users to choose their preferred implementation without requiring knowledge of the other (root README provides language navigation to detailed READMEs in scitt-typescript/ and scitt-golang/)
- **FR-012**: Directory structures within each implementation MUST follow parallel organization patterns: (1) same conceptual modules (keys/, identity/, statement/, receipt/, merkle/), (2) similar subdirectory nesting depth, (3) language-idiomatic naming (src/ for TypeScript, pkg/ for Go, internal/ for Go private packages), with cross-implementation tests in top-level tests/interop/
- **FR-013**: Both implementations MUST maintain 100% interoperability as defined in Constitution Principle VIII
- **FR-014**: Command-line help output MUST be consistent across implementations (command names, flag names, descriptions)
- **FR-015**: Both implementations MUST support the same configuration file formats and environment variables
- **FR-016**: Error messages and status codes MUST be consistent across implementations for equivalent operations
- **FR-017**: Performance characteristics MUST meet equivalent targets (defined in implementation plan)
- **FR-018**: Both implementations MUST support the same IETF standards (SCITT, COSE RFC 8152, CWT RFC 8392, RFC 6962)
- **FR-019**: .well-known endpoint responses MUST be structurally identical across implementations
- **FR-020**: Cross-implementation test failures MUST block releases of both implementations (strict lockstep versioning requires simultaneous releases)
- **FR-021**: Both implementations MUST maintain identical version numbers at all times (e.g., both 1.0.0, both 1.0.1)
- **FR-022**: Existing TypeScript code MUST be directly moved to `scitt-typescript/` with updated import paths (no compatibility shims)
- **FR-023**: Root README MUST provide clear language choice navigation with links to scitt-typescript/README.md and scitt-golang/README.md
- **FR-024**: Project MUST use monorepo structure (single repository) to enable atomic commits, shared CI/CD, and coordinated releases

### Key Entities

- **Language Implementation**: Represents one complete implementation (TypeScript or Go) with library, CLI, and server components
- **Cryptographic Key**: Signing keys generated by either implementation, interoperable across both
- **Issuer Identity**: Identity artifacts including keys and metadata, hostable at .well-known URIs
- **Statement**: Transparency log entries created by issuers, following SCITT specification
- **Signed Statement**: Statements with COSE Sign1 cryptographic signatures
- **Receipt**: Cryptographic proof of statement registration including inclusion proof
- **Cross-Implementation Test**: Automated test that validates interoperability by using artifacts from one implementation in the other
- **Interoperability Artifact**: Any file or data structure (keys, statements, receipts) that must work identically across implementations

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Users can complete quick start in their chosen language within 5 minutes without encountering instructions for the other language
- **SC-002**: 100% of cross-implementation interoperability tests pass for all artifact types (keys, statements, receipts)
- **SC-003**: CLI command structure is identical across implementations (same command names, flag names, and output formats)
- **SC-004**: Both server implementations respond to identical API requests with structurally equivalent responses (SCRAPI endpoints: same schema with deterministic CBOR, different signatures allowed; Tile data: byte-identical binary; Checkpoint payloads: same structure, different signatures allowed)
- **SC-005**: Documentation provides parallel paths where a user can complete all tasks using only their chosen implementation's instructions
- **SC-006**: Performance targets are equivalent (both implementations meet same latency/throughput goals)
- **SC-007**: Both implementations pass the same SCITT conformance test suite (when available)
- **SC-008**: New developers can switch implementations without relearning fundamental concepts (90% concept reuse based on user feedback)
- **SC-009**: Cross-implementation artifact exchange succeeds for 100% of test cases without any modification or transformation
- **SC-010**: Directory structure parallel between implementations allows developers familiar with one to navigate the other without documentation

## Assumptions *(included when present)*

1. **Go Implementation Standards**: Go implementation follows Principle VIII as canonical reference, TypeScript implementation conforms to Go behavior
2. **Test Vector Source**: Interoperability test vectors are generated using the Go implementation as source of truth
3. **Version Synchronization**: Both implementations maintain strict lockstep versioning - identical version numbers always (e.g., both at 1.0.0, both at 1.0.1)
4. **Documentation Structure**: Root README provides language navigation and overview; each implementation has detailed README with language-specific examples (intentional duplication for user independence)
5. **Existing Tests**: Current interoperability tests (tests/interop/) provide foundation for expanded cross-implementation testing
6. **Build Tooling**: TypeScript uses Bun as specified, Go uses standard Go tooling
7. **Shared Standards**: Both implementations target identical IETF standards without deviation
8. **Independent Deployability**: Each implementation can be deployed, tested, and released independently once interoperability tests pass
9. **CI/CD Strategy**: Monorepo enables shared continuous integration that runs both implementation test suites and cross-tests atomically; failures in cross-tests block both implementations
10. **Migration Path**: Existing TypeScript code will be directly moved to `scitt-typescript/` structure; users must update imports when upgrading to the restructured version (breaking change for import paths, but API remains compatible)
